<!DOCTYPE html>
<html lang="zh">
    <head>
    <!--
        © Material Theme
        https://github.com/viosey/hexo-theme-material
        Version: 1.3.3 -->

    <!-- Title -->
    
    <title>
        
        koala
    </title>

    <!-- Meta & Info -->
    <meta charset="utf-8">

    <!-- dns prefetch -->
    <meta http-equiv="x-dns-prefetch-control" content="on">
    
    
    
    
    
    

    <meta http-equiv="X-UA-Compatible">
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <meta name="theme-color" content="#0097A7">
    <meta name="author" content="koala">
    <meta name="description" content="blog.koala.me">
    <meta name="keywords" content="null">

    <!-- Favicons -->
    <link rel="icon shortcut" type="image/ico" href="/img/favicon.png">
    <link rel="icon" sizes="192x192" href="/img/favicon.png">
    <link rel="apple-touch-icon" href="/img/favicon.png">

    <!--iOS -->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">
    <meta name="apple-mobile-web-app-title" content="Title">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="HandheldFriendly" content="True">
    <meta name="MobileOptimized" content="480">

    <!-- Add to homescreen for Chrome on Android -->
    <meta name="mobile-web-app-capable" content="yes">

    <!-- Add to homescreen for Safari on iOS -->
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black">
    <meta name="apple-mobile-web-app-title" content="koala">

    <!-- The Open Graph protocol -->
    <meta property="og:url" content="http://blog.koala.me">
    <meta property="og:type" content="blog">
    <meta property="og:title" content="koala">
    <meta property="og:description" content="blog.koala.me">
    

    <!--[if lte IE 9]>
        <link rel="stylesheet" href="/css/ie-blocker.css">

        
            <script src="/js/ie-blocker.zhCN.js"></script>
        
    <![endif]-->

    <!-- Import CSS & jQuery -->
    
        <link rel="stylesheet" href="/css/material.min.css">
        <link rel="stylesheet" href="/css/style.min.css">
        <!-- Config CSS -->


<!-- Other Styles -->
<style>
  body, html {
    font-family: Roboto, "Helvetica Neue", Helvetica, "PingFang SC", "Hiragino Sans GB", "Microsoft YaHei", "微软雅黑", Arial, sans-serif;
  }

  a {
    color: #00838F;
  }

  .mdl-card__media,
  #search-label,
  #search-form-label:after,
  #scheme-Paradox .hot_tags-count,
  #scheme-Paradox .sidebar_archives-count,
  #scheme-Paradox .sidebar-colored .sidebar-header,
  #scheme-Paradox .sidebar-colored .sidebar-badge{
    background-color: #0097A7 !important;
  }

  /* Sidebar User Drop Down Menu Text Color */
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:hover,
  #scheme-Paradox .sidebar-colored .sidebar-nav>.dropdown>.dropdown-menu>li>a:focus {
    color: #0097A7 !important;
  }

  #post_entry-right-info,
  .sidebar-colored .sidebar-nav li:hover > a,
  .sidebar-colored .sidebar-nav li:hover > a i,
  .sidebar-colored .sidebar-nav li > a:hover,
  .sidebar-colored .sidebar-nav li > a:hover i,
  .sidebar-colored .sidebar-nav li > a:focus i,
  .sidebar-colored .sidebar-nav > .open > a,
  .sidebar-colored .sidebar-nav > .open > a:hover,
  .sidebar-colored .sidebar-nav > .open > a:focus,
  #ds-reset #ds-ctx .ds-ctx-entry .ds-ctx-head a {
    color: #0097A7 !important;
  }

  .toTop {
    background: #757575 !important;
  }

  .material-layout .material-post>.material-nav,
  .material-layout .material-index>.material-nav,
  .material-nav a {
    color: #757575;
  }

  #scheme-Paradox .MD-burger-layer {
    background-color: #757575;
  }

  #scheme-Paradox #post-toc-trigger-btn {
    color: #757575;
  }

  .post-toc a:hover {
    color: #00838F;
    text-decoration: underline;
  }

</style>


<!-- Theme Background Related-->

    <style>
      body{
        background-color: #F5F5F5;
      }

      /* blog_info bottom background */
      #scheme-Paradox .material-layout .something-else .mdl-card__supporting-text{
        background-color: #fff;
      }
    </style>




<!-- Fade Effect -->

    <style>
      .fade {
        transition: all 800ms linear;
        -webkit-transform: translate3d(0,0,0);
        -moz-transform: translate3d(0,0,0);
        -ms-transform: translate3d(0,0,0);
        -o-transform: translate3d(0,0,0);
        transform: translate3d(0,0,0);
        opacity: 1;
      }

      .fade.out{
        opacity: 0;
      }
    </style>


        <script src="/js/jquery.min.js"></script>
        <script src="/js/queue.js"></script>
    

    <!-- UC Browser Compatible -->
    <script>
        var agent = navigator.userAgent.toLowerCase();
        if(agent.indexOf('ucbrowser')>0) {
            document.write("<link rel=\"stylesheet\" href=\"/css/uc.css\">");
            alert('由于 UC 浏览器使用极旧的内核，而本网站使用了一些新的特性。\n为了您能更好的浏览，推荐使用 Chrome 或 Firefox 浏览器。');
        }
    </script>

    

    


    <!-- Bing Background -->
    

    <!-- Custom Head -->
    
</head>


    
        <body id="scheme-Paradox" class="lazy">
            <div class="material-layout  mdl-js-layout has-drawer is-upgraded">
                

                <!-- Main Container -->
                <main class="material-layout__content" id="main">

                    <!-- Top Anchor -->
                    <div id="top"></div>

                    
                        <!-- Hamburger Button -->
                        <button class="MD-burger-icon sidebar-toggle">
                            <span class="MD-burger-layer"></span>
                        </button>
                    

                    <!-- Post TOC -->

    
    <!-- Back Button -->
    <!--
    <div class="material-back" id="backhome-div" tabindex="0">
        <a class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon"
           href="#" onclick="window.history.back();return false;"
           target="_self"
           role="button"
           data-upgraded=",MaterialButton,MaterialRipple">
            <i class="material-icons" role="presentation">arrow_back</i>
            <span class="mdl-button__ripple-container">
                <span class="mdl-ripple"></span>
            </span>
        </a>
    </div>
    -->

    <!-- Left aligned menu below button -->
    <button id="post-toc-trigger-btn"
        class="mdl-button mdl-js-button mdl-button--icon">
        <i class="material-icons">format_list_numbered</i>
    </button>

    <ul class="post-toc-wrap mdl-menu mdl-menu--bottom-left mdl-js-menu mdl-js-ripple-effect" for="post-toc-trigger-btn" style="max-height:80vh; overflow-y:scroll;">
        <ol class="post-toc"><li class="post-toc-item post-toc-level-6"><a class="post-toc-link" href="#此方法主要处理偏移回归的动画-写在一个Runable子线程中"><span class="post-toc-number">1.</span> <span class="post-toc-text">此方法主要处理偏移回归的动画 写在一个Runable子线程中</span></a></li></ol>

        <!--
        <li class="mdl-menu__item">
            Some Action
        </li>
        -->
    </ul>




<!-- Layouts -->

    <!-- Post Module -->
    <div class="material-post_container">

        <div class="material-post mdl-grid">
            <div class="mdl-card mdl-shadow--4dp mdl-cell mdl-cell--12-col">

                <!-- Post Header(Thumbnail & Title) -->
                
    <!-- Paradox Post Header -->
    
        
            <!-- Random Thumbnail -->
            <div class="post_thumbnail-random mdl-card__media mdl-color-text--grey-50">
            <script>
    var randomNum = Math.floor(Math.random() * 19 + 1);

    $('.post_thumbnail-random').attr('data-original', '/img/random/material-' + randomNum + '.png');
    $('.post_thumbnail-random').addClass('lazy');
</script>

        
    
            <p class="article-headline-p">
                
            </p>
        </div>





                
                    <!-- Paradox Post Info -->
                    <div class="mdl-color-text--grey-700 mdl-card__supporting-text meta">

    <!-- Author Avatar -->
    <div id="author-avatar">
        <img src="/img/avatar.png" width="44px" height="44px" alt="Author Avatar"/>
    </div>
    <!-- Author Name & Date -->
    <div>
        <strong>koala</strong>
        <span>5月 06, 2017</span>
    </div>

    <div class="section-spacer"></div>

    <!-- Favorite -->
    <!--
        <button id="article-functions-like-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon btn-like">
            <i class="material-icons" role="presentation">favorite</i>
            <span class="visuallyhidden">favorites</span>
        </button>
    -->

    <!-- Qrcode -->
    

    <!-- Tags (bookmark) -->
    
    <button id="article-functions-viewtags-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
        <i class="material-icons" role="presentation">bookmark</i>
        <span class="visuallyhidden">bookmark</span>
    </button>
    <ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-functions-viewtags-button">
        <li class="mdl-menu__item">
        
    </ul>
    

    <!-- Share -->
    <button id="article-fuctions-share-button" class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon">
    <i class="material-icons" role="presentation">share</i>
    <span class="visuallyhidden">share</span>
</button>
<ul class="mdl-menu mdl-menu--bottom-right mdl-js-menu mdl-js-ripple-effect" for="article-fuctions-share-button">
    

    

    <!-- Share Weibo -->
    
        <a class="post_share-link" href="http://service.weibo.com/share/share.php?appkey=&title=&url=http://blog.koala.me//2017/05/06/可能是最详细的UCrop源码解析/index.html&pic=&searchPic=false&style=simple" target="_blank">
            <li class="mdl-menu__item">
                分享到微博
            </li>
        </a>
    

    <!-- Share Twitter -->
    
        <a class="post_share-link" href="https://twitter.com/intent/tweet?text=&url=http://blog.koala.me//2017/05/06/可能是最详细的UCrop源码解析/index.html&via=koala" target="_blank">
            <li class="mdl-menu__item">
                分享到 Twitter
            </li>
        </a>
    

    <!-- Share Facebook -->
    
        <a class="post_share-link" href="https://www.facebook.com/sharer/sharer.php?u=http://blog.koala.me//2017/05/06/可能是最详细的UCrop源码解析/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Facebook
            </li>
        </a>
    

    <!-- Share Google+ -->
    
        <a class="post_share-link" href="https://plus.google.com/share?url=http://blog.koala.me//2017/05/06/可能是最详细的UCrop源码解析/index.html" target="_blank">
            <li class="mdl-menu__item">
                分享到 Google+
            </li>
        </a>
    

    <!-- Share LinkedIn -->
    

    <!-- Share QQ -->
    

    <!-- Share Telegram -->
    
</ul>

</div>

                

                <!-- Post Content -->
                <div id="post-content" class="mdl-color-text--grey-700 mdl-card__supporting-text fade out">
    
        <p>UCrop是目前比较火的开源android图片剪裁框架，效果如下:</p>
<p><img src="http://upload-images.jianshu.io/upload_images/2001089-346486331d94e513.gif?imageMogr2/auto-orient/strip" alt="preview.gif"></p>
<blockquote>
<p>地址：<br><a href="https://github.com/Yalantis/uCrop" target="_blank" rel="external">Git源码地址</a><br><a href="http://blog.csdn.net/wood_water_peng/article/details/51306274" target="_blank" rel="external">以及作者自己的逻辑解析-中文翻译</a><br><a href="https://yalantis.com/blog/how-we-created-ucrop-our-own-image-cropping-library-for-android/" target="_blank" rel="external">原版英文解析</a></p>
</blockquote>
<p>本文重点解释核心功能代码，梳理项目流程，建议阅读时结合源码一起看~。</p>
<hr>
<p>#####业务流程：<br>选择图片（从系统图片库选择图片）→ 放置图片（把图片放置到操作台）→ 操作图片（包括旋转，缩放，位移等操作来得到需要的图片）→ 剪裁图片（根据原始比例剪裁框剪裁目标图片或根据给定的比例剪裁）→ 获得目标图片（返回bitmap并保存到本地）</p>
<p>#####代码结构解析：<br>项目使用Bulider设计模式，结构功能分工明确，下面就来看看作者是怎么实现的，注意看核心代码的注释<br>代码结构大致分为三个部分：  </p>
<ul>
<li><p>第一部分：  UCropAcitivity（图片的操作窗口）<br>它主要作为项目的入口和一些初始化工作以及加载自定义View；<br>使用时直接传入一个目标图片的URI和目标存储文件的URI即可开始剪裁。<br>这里作者封装了一个UCropActivity的helper类UCrop，把startActivityForResult和Bundle封装在了里面，Options内部类用作用户初始参数配置包括（setToolbarCropDrawable设置toolbar图片，setToolbarTitle标题等等）。</p>
<p>UCropActivity中包含自定义UCropView，UCropView中包含        GestureCropImageView和OverlayView两个自定义View。</p>
<p>OverlayView负责绘制剪裁框<br>GestureCropImageView负责操作选择图片</p>
</li>
<li><p>第二部分：OverlayView-负责绘制剪裁框</p>
<p>View在初始化的时候做了判断，当系统大于3.0小于4.3时启动硬件加速，为什么选择这个区间呢，因为在android系统3.0之前android还不支持硬件加速，而在4.3之后Android 4.4，也就是KitKat版本，这个版本对内存方法做了很大的优化：一方面是通过优化内存使用，另一方面是可选地支持使用ART运行时替换Dalvik虚拟机，来提高应用程序的运行效率，所以选择4.4之后不开启硬件加速。</p>
<p>剪裁框的绘制主要分为两个部分：<br>1、drawlines()绘制剪裁框内分割线段,<br>2、drawRect()绘制矩形，从而形成了一个带横纵线平均分割的矩形剪裁框</p>
<p>  核心方法：<br>drawCropGrid()该方法主要功能为绘制剪裁框,根据设定的剪裁框分割线数量使用canvas.drawlines()方法绘制分割线和限制矩形，具体代码如下：<br>绘制剪裁框：</p>
<pre><code>protected void drawCropGrid(@NonNull Canvas canvas) {
 //判断是否显示剪裁框
 if (mShowCropGrid) {
     //判断矩形数据是否为空，mGridPoints如果等于空的话进入填充数据
     if (mGridPoints == null &amp;&amp; !mCropViewRect.isEmpty()) {
         //该数组为canvas.drawLines的第一个参数，该参数要求其元素个数为4的倍数
         mGridPoints = new float[(mCropGridRowCount) * 4 + (mCropGridColumnCount) * 4];
         int index = 0;
         //组装数据，数据为每一组线段的坐标点
         for (int i = 0; i &lt; mCropGridRowCount; i++) {
             mGridPoints[index++] = mCropViewRect.left;
             mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) (mCropGridRowCount + 1))) + mCropViewRect.top;
             mGridPoints[index++] = mCropViewRect.right;
             mGridPoints[index++] = (mCropViewRect.height() * (((float) i + 1.0f) / (float) (mCropGridRowCount + 1))) + mCropViewRect.top;
         }

         for (int i = 0; i &lt; mCropGridColumnCount; i++) {
             mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) (mCropGridColumnCount + 1))) + mCropViewRect.left;
             mGridPoints[index++] = mCropViewRect.top;
             mGridPoints[index++] = (mCropViewRect.width() * (((float) i + 1.0f) / (float) (mCropGridColumnCount + 1))) + mCropViewRect.left;
             mGridPoints[index++] = mCropViewRect.bottom;
         }
     }
     //绘制线段
     if (mGridPoints != null) {
         canvas.drawLines(mGridPoints, mCropGridPaint);
     }
 }
 //绘制矩形包裹线段
 if (mShowCropFrame) {
     canvas.drawRect(mCropViewRect, mCropFramePaint);
 }
 //绘制边角包裹,mFreestyleCropMode此参数如果等于1的话 剪裁框为可移动状态，一般不用
 if (mFreestyleCropMode != FREESTYLE_CROP_MODE_DISABLE) {
     canvas.save();

     mTempRect.set(mCropViewRect);
     mTempRect.inset(mCropRectCornerTouchAreaLineLength, -mCropRectCornerTouchAreaLineLength);
     canvas.clipRect(mTempRect, Region.Op.DIFFERENCE);

     mTempRect.set(mCropViewRect);
     mTempRect.inset(-mCropRectCornerTouchAreaLineLength, mCropRectCornerTouchAreaLineLength);
     canvas.clipRect(mTempRect, Region.Op.DIFFERENCE);

     canvas.drawRect(mCropViewRect, mCropFrameCornersPaint);

     canvas.restore();
 }
</code></pre><p>  }<br>这部分主要负责第一层的剪裁框绘制，保存剪裁框矩阵用于后期剪裁用</p>
</li>
</ul>
<hr>
<p>#####第三部分：GestureCropImageView-负责操作选择图片</p>
<p>  这一部分应该是项目最核心的部分，实现逻辑作者在他的说明文章中也说的比较清楚。<br>这一部分的逻辑解耦做的非常好，把View的功能逻辑划分为3层，每一层负责各自的功能：  </p>
<ul>
<li><p>第一层：<br>TransformImageView extends ImageView<br>他的工作：<br>1.从图片源拿到图片<br>2.将矩阵进行转换(平移、缩放、旋转)，并应用到当前图片上<br>这一层并不知道裁剪或者手势等行为，但提供了手势行为操作供子类调用。<br>这里作者选择使用ImageView的Matrix做旋转缩放而没有使用重写onDraw方法，因为onDraw方法重绘有可能会有闪屏的情况而且在性能比较差的机器上可能体验会很差，使用Matrix则会好许多。<br>Matrix在android中其实一个3*3的矩阵如下：<br>MSCALE_X  MSKEW_X MTRANS_X<br>MSKEY_Y MSCALE_Y MTRANS_Y<br>MPERSP_0 MPERSP_1  MPERSP_2<br>Matrix对图像的处理分为四类基本变换：<br>Translate  平移变换<br>Rotate      旋转变换<br>Scale       缩放变换<br>Skew       错切变换<br>在项目中只用到了前三种，它们对应的api如下：<br>//平移变换，在X轴上平移x多个距离，在Y轴上平移y多个距离<br>postTranslate(float x,floaty);</p>
<p>//旋转变换，degrees旋转度数，px，py旋转原点<br>postRotate(float degrees,float px,float py);</p>
<p>//缩放变换 x变换距离，y变换距离，px，py缩放原点<br>postScale(float sx,float sx,float px,float py);</p>
<p>作者在这一层写了postTranslate，postScale，postRotate三个方法暴露给子类调用，封装Matrix属性后在调用setImageMatrix()实现变换效果，mCurrentImageMatrix.mapPoints这个方法为更新当前图像的角点和存储的中心点，这些变量在CropImageView中会被使用到. </p>
<p>关于Matrix的用法不熟悉的可以看这里<a href="http://www.jcodecraeer.com/a/anzhuokaifa/androidkaifa/2013/1023/1579.html" target="_blank" rel="external">Matrix</a><br><a href="https://github.com/GcsSloop/AndroidNote/blob/master/CustomView/Advance/%5B09%5DMatrix_Basic.md" target="_blank" rel="external">Matrix原理</a></p>
</li>
<li><p>第二层:<br>CropImageView extends TransformImageView<br>他要做的事:<br>1.画出裁剪的边界和网格<br>2.为裁剪区域设置一张图片（如果用户对图片操作导致裁剪区域内出现了空白，那么图片应该要自动移动到边界填充空白区域）<br>3.继承父亲的方法，使用更精细的规则来操作矩阵（限制最小和最大的缩放比例）<br>4.添加方法和缩小的方法（动画变换）<br>5.裁剪图片<br>这一层几乎囊括了所有的要对图片进行变换和裁剪的所有操作,但也仅仅是指明了做这些事情的方法，我们还需要支持手势。 </p>
<p>在这一层中作者重写了onImageLaidOut方法，该方法为上层View TransformImageView的图片加载完毕回调方法，在此方法中作者设置了初始要剪裁的矩形，并且把图片移动到屏幕居中的位置操作（因为ImageView设置的ScaleType为Matrix所以图像一开始是默认在屏幕上方的）</p>
<p>这一层中的操作大概可以分为三步操作：图片偏移剪裁框偏移计算、图片归位动画处理，剪裁图片<br>第一步（也是最复杂的一种）：<br>当手指离开屏幕时要保证图片处于剪裁区域中如果不在剪裁区域中通过位移变换来移动到剪裁区域，看代码：  </p>
<pre><code>public void setImageToWrapCropBounds(boolean animate) {
 //如果图片加载完毕并且图片不处于剪裁区域
 if (mBitmapLaidOut &amp;&amp; !isImageWrapCropBounds()) {

     //获取中心点X,Y坐标
     float currentX = mCurrentImageCenter[0];
     float currentY = mCurrentImageCenter[1];
     //获取缩放比例
     float currentScale = getCurrentScale();

     //获取偏移距离
     float deltaX = mCropRect.centerX() - currentX;
     float deltaY = mCropRect.centerY() - currentY;
     float deltaScale = 0;

     mTempMatrix.reset();
     mTempMatrix.setTranslate(deltaX, deltaY);

     final float[] tempCurrentImageCorners = Arrays.copyOf(mCurrentImageCorners, mCurrentImageCorners.length);
     mTempMatrix.mapPoints(tempCurrentImageCorners);

     //判断图片是否包含在剪裁区域
     boolean willImageWrapCropBoundsAfterTranslate = isImageWrapCropBounds(tempCurrentImageCorners);

     //如果包含在剪裁区域
     if (willImageWrapCropBoundsAfterTranslate) {
         //获取偏移的距离
         final float[] imageIndents = calculateImageIndents();
         //偏移的距离，横坐标加横坐标 纵坐标加纵坐标
         deltaX = -(imageIndents[0] + imageIndents[2]);
         deltaY = -(imageIndents[1] + imageIndents[3]);
     } else {
         //如果不包含在剪裁区域，创建临时矩形
         RectF tempCropRect = new RectF(mCropRect);
         mTempMatrix.reset();
         //设置偏移角度
         mTempMatrix.setRotate(getCurrentAngle());
         mTempMatrix.mapRect(tempCropRect);

         //获得矩形的边长坐标
         final float[] currentImageSides = RectUtils.getRectSidesFromCorners(mCurrentImageCorners);
         //获取放大比例
         deltaScale = Math.max(tempCropRect.width() / currentImageSides[0],
                 tempCropRect.height() / currentImageSides[1]);
         deltaScale = deltaScale * currentScale - currentScale;
     }

     //如果需要动画
     if (animate) {
         post(mWrapCropBoundsRunnable = new WrapCropBoundsRunnable(
                 CropImageView.this, mImageToWrapCropBoundsAnimDuration, currentX, currentY, deltaX, deltaY,
                 currentScale, deltaScale, willImageWrapCropBoundsAfterTranslate));
     } else {
         //不需要动画，直接移动到目标位置
         postTranslate(deltaX, deltaY);
         if (!willImageWrapCropBoundsAfterTranslate) {
             zoomInImage(currentScale + deltaScale, mCropRect.centerX(), mCropRect.centerY());
         }
     }
 }
</code></pre><p>  }</p>
</li>
</ul>
<p>第二步：作者在这里使用了一个Runable线程来操作，使用时间差值的计算来移动动画，使动画看起来更真实</p>
<h6 id="此方法主要处理偏移回归的动画-写在一个Runable子线程中"><a href="#此方法主要处理偏移回归的动画-写在一个Runable子线程中" class="headerlink" title="此方法主要处理偏移回归的动画 写在一个Runable子线程中"></a>此方法主要处理偏移回归的动画 写在一个Runable子线程中</h6><pre><code>/**
 * This Runnable is used to animate an image so it fills the crop bounds entirely.
 * Given values are interpolated during the animation time.
 * Runnable can be terminated either vie {@link #cancelAllAnimations()} method
 * or when certain conditions inside {@link WrapCropBoundsRunnable#run()} method are triggered.
 * 在这里，我计算出当前流逝的时间，使用CubicEasing这个类，我对平移量和缩放量进行插值操作。
 * 使用插值器替换过的值确实可以改善你的动画，使人们的眼睛看起来更自然。
 * 最终，这些值被应用到图片矩阵，当时间溢出或者图片完全填充了裁剪区域的时候，Runnable任务就会停止。
 */
private static class WrapCropBoundsRunnable implements Runnable {

    private final WeakReference&lt;CropImageView&gt; mCropImageView;

    private final long mDurationMs, mStartTime;
    private final float mOldX, mOldY;
    private final float mCenterDiffX, mCenterDiffY;
    private final float mOldScale;
    private final float mDeltaScale;
    private final boolean mWillBeImageInBoundsAfterTranslate;

    public WrapCropBoundsRunnable(CropImageView cropImageView,
                                  long durationMs,
                                  float oldX, float oldY,
                                  float centerDiffX, float centerDiffY,
                                  float oldScale, float deltaScale,
                                  boolean willBeImageInBoundsAfterTranslate) {

        mCropImageView = new WeakReference&lt;&gt;(cropImageView);

        mDurationMs = durationMs;
        mStartTime = System.currentTimeMillis();
        mOldX = oldX;
        mOldY = oldY;
        mCenterDiffX = centerDiffX;
        mCenterDiffY = centerDiffY;
        mOldScale = oldScale;
        mDeltaScale = deltaScale;
        mWillBeImageInBoundsAfterTranslate = willBeImageInBoundsAfterTranslate;
    }

    @Override
    public void run() {
        CropImageView cropImageView = mCropImageView.get();
        if (cropImageView == null) {
            return;
        }

        long now = System.currentTimeMillis();
        //花费的时间，最多500ms，
        float currentMs = Math.min(mDurationMs, now - mStartTime);

        //计算出当前流逝的时间，我对平移量和缩放量进行插值操作。
        float newX = CubicEasing.easeOut(currentMs, 0, mCenterDiffX, mDurationMs);
        float newY = CubicEasing.easeOut(currentMs, 0, mCenterDiffY, mDurationMs);
        float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs);

        //如果时间溢出 停止任务
        if (currentMs &lt; mDurationMs) {
            cropImageView.postTranslate(newX - (cropImageView.mCurrentImageCenter[0] - mOldX), newY - (cropImageView.mCurrentImageCenter[1] - mOldY));
            if (!mWillBeImageInBoundsAfterTranslate) {
                cropImageView.zoomInImage(mOldScale + newScale, cropImageView.mCropRect.centerX(), cropImageView.mCropRect.centerY());
            }
            //如果图片还没填充满剪裁区域，继续移动
            if (!cropImageView.isImageWrapCropBounds()) {
                cropImageView.post(this);
            }
        }
    }
}
</code></pre><p>######另一个Runable方法类，用于双击放大时使用<br>同样使用了时间差值计算偏移大小动画<br>MaxScale为图片最大的放大值，大小为最小尺寸的10倍<br>minScale为图片缩小的最小值，大小为初始矩形的宽和高分别除以剪裁框的宽高取最小值。</p>
<pre><code>/**
 * This Runnable is used to animate an image zoom.
 * Given values are interpolated during the animation time.
 * Runnable can be terminated either vie {@link #cancelAllAnimations()} method
 * or when certain conditions inside {@link ZoomImageToPosition#run()} method are triggered.
 */
private static class ZoomImageToPosition implements Runnable {

    private final WeakReference&lt;CropImageView&gt; mCropImageView;

    private final long mDurationMs, mStartTime;
    private final float mOldScale;
    private final float mDeltaScale;
    private final float mDestX;
    private final float mDestY;

    public ZoomImageToPosition(CropImageView cropImageView,
                               long durationMs,
                               float oldScale, float deltaScale,
                               float destX, float destY) {

        mCropImageView = new WeakReference&lt;&gt;(cropImageView);

        mStartTime = System.currentTimeMillis();
        mDurationMs = durationMs;
        mOldScale = oldScale;
        mDeltaScale = deltaScale;
        mDestX = destX;
        mDestY = destY;
    }

    @Override
    public void run() {
        CropImageView cropImageView = mCropImageView.get();
        if (cropImageView == null) {
            return;
        }

        long now = System.currentTimeMillis();
        float currentMs = Math.min(mDurationMs, now - mStartTime);
        float newScale = CubicEasing.easeInOut(currentMs, 0, mDeltaScale, mDurationMs);

        if (currentMs &lt; mDurationMs) {
            cropImageView.zoomInImage(mOldScale + newScale, mDestX, mDestY);
            cropImageView.post(this);
        } else {
            cropImageView.setImageToWrapCropBounds();
        }
    }

}
</code></pre><ul>
<li>第三步：最后一步，剪裁图片</li>
</ul>
<pre><code> /**
 * Cancels all current animations and sets image to fill crop area (without animation).
 * Then creates and executes {@link BitmapCropTask} with proper parameters.
 */
public void cropAndSaveImage(@NonNull Bitmap.CompressFormat compressFormat, int compressQuality,
                           @Nullable BitmapCropCallback cropCallback) {
  //结束子线程
  cancelAllAnimations();
  //设置要剪裁的图片，不需要位移动画
  setImageToWrapCropBounds(false);

  //存储图片信息，四个参数分别为：mCropRect要剪裁的图片矩阵，当前图片要剪裁的矩阵，当前放大的值，当前旋转的角度
  final ImageState imageState = new ImageState(
          mCropRect, RectUtils.trapToRect(mCurrentImageCorners),
          getCurrentScale(), getCurrentAngle());

  //剪裁参数，mMaxResultImageSizeX，mMaxResultImageSizeY：剪裁图片的最大宽度、高度。
  final CropParameters cropParameters = new CropParameters(
          mMaxResultImageSizeX, mMaxResultImageSizeY,
          compressFormat, compressQuality,
          getImageInputPath(), getImageOutputPath(), getExifInfo());
  //剪裁操作放到AsyncTask中执行
  new BitmapCropTask(getViewBitmap(), imageState, cropParameters, cropCallback).execute();
}
</code></pre><p>剪裁部分的核心代码：       float resizeScale = resize();   crop(resizeScale);</p>
<pre><code>       //调整剪裁大小，如果有设置最大剪裁大小也会在这里做调整到设置范围
   private float resize() {
    final BitmapFactory.Options options = new BitmapFactory.Options();
    options.inJustDecodeBounds = true;
    BitmapFactory.decodeFile(mImageInputPath, options);

    boolean swapSides = mExifInfo.getExifDegrees() == 90 || mExifInfo.getExifDegrees() == 270;
    float scaleX = (swapSides ? options.outHeight : options.outWidth) / (float) mViewBitmap.getWidth();
    float scaleY = (swapSides ? options.outWidth : options.outHeight) / (float) mViewBitmap.getHeight();

    float resizeScale = Math.min(scaleX, scaleY);

    mCurrentScale /= resizeScale;

    resizeScale = 1;
    if (mMaxResultImageSizeX &gt; 0 &amp;&amp; mMaxResultImageSizeY &gt; 0) {
        float cropWidth = mCropRect.width() / mCurrentScale;
        float cropHeight = mCropRect.height() / mCurrentScale;

        if (cropWidth &gt; mMaxResultImageSizeX || cropHeight &gt; mMaxResultImageSizeY) {

            scaleX = mMaxResultImageSizeX / cropWidth;
            scaleY = mMaxResultImageSizeY / cropHeight;
            resizeScale = Math.min(scaleX, scaleY);

            mCurrentScale /= resizeScale;
        }
    }
    return resizeScale;
}

  /**
  *    剪裁图片
  */
  private boolean crop(float resizeScale) throws IOException {
    ExifInterface originalExif = new ExifInterface(mImageInputPath);

    //四舍五入取整
    int top = Math.round((mCropRect.top - mCurrentImageRect.top) / mCurrentScale);
    int left = Math.round((mCropRect.left - mCurrentImageRect.left) / mCurrentScale);
    mCroppedImageWidth = Math.round(mCropRect.width() / mCurrentScale);
    mCroppedImageHeight = Math.round(mCropRect.height() / mCurrentScale);

    //计算出图片是否需要被剪裁
    boolean shouldCrop = shouldCrop(mCroppedImageWidth, mCroppedImageHeight);
    Log.i(TAG, &quot;Should crop: &quot; + shouldCrop);
    if (shouldCrop) {
        //调用C++方法剪裁
        boolean cropped = cropCImg(mImageInputPath, mImageOutputPath,
                left, top, mCroppedImageWidth, mCroppedImageHeight, mCurrentAngle, resizeScale,
                mCompressFormat.ordinal(), mCompressQuality,
                mExifInfo.getExifDegrees(), mExifInfo.getExifTranslation());
        //剪裁成功复制图片EXIF信息
        if (cropped &amp;&amp; mCompressFormat.equals(Bitmap.CompressFormat.JPEG)) {
            ImageHeaderParser.copyExif(originalExif, mCroppedImageWidth, mCroppedImageHeight, mImageOutputPath);
        }
        return cropped;
    } else {
        //直接复制图片到目标文件夹
        FileUtils.copyFile(mImageInputPath, mImageOutputPath);
        return false;
    }
}
</code></pre><p>######第三层：<br>GestureImageView extends CropImageView<br>他的功能：<br>监听用户的手势，调用合适的方法</p>
<p>由于系统对手势操作已经有了监听方法，所以作者在这里使用了系统的监听方法：<br>ScaleGestureDetector：用来检测两个手指在屏幕上做缩放的手势。<br>GestureListener：这个类我们可以识别很多的手势，作者在这里重写了双击onDoubleTap，拖动onScroll，两种手势处理。<br>RotationGestureDetector：两只以上的手指触摸屏幕才会产生旋转事件用这个接口回调。 </p>
<pre><code>  /**
 * If it&apos;s ACTION_DOWN event - user touches the screen and all current animation must be canceled.
 * If it&apos;s ACTION_UP event - user removed all fingers from the screen and current image position must be corrected.
 * If there are more than 2 fingers - update focal point coordinates.
 * Pass the event to the gesture detectors if those are enabled.
 */
@Override
public boolean onTouchEvent(MotionEvent event) {
    if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_DOWN) {
        cancelAllAnimations();
    }

    if (event.getPointerCount() &gt; 1) {
        mMidPntX = (event.getX(0) + event.getX(1)) / 2;
        mMidPntY = (event.getY(0) + event.getY(1)) / 2;
    }

    //双击监听和拖动监听
    mGestureDetector.onTouchEvent(event);
    //两指缩放监听
    if (mIsScaleEnabled) {
        mScaleDetector.onTouchEvent(event);
    }
    //旋转监听
    if (mIsRotateEnabled) {
        mRotateDetector.onTouchEvent(event);
    }
    if ((event.getAction() &amp; MotionEvent.ACTION_MASK) == MotionEvent.ACTION_UP) {
        //最后一指抬起时判断图片是否填充剪裁框
        setImageToWrapCropBounds();
    }
    return true;
}
</code></pre><p>大致的核心逻辑基本就这些<br>项目中的异步操作使用AsyncTask，一共两个主要的AsyncTask：BitmapLoadTask用于初次进入load图片，BitmapCropTask图片剪裁异步操作。</p>
<hr>
<p>######项目涉及到的技术点：<br>自定义View，手势操作监听，Matrix实现图片变换缩放，Canvas绘制View，exif存储图片信息，文件存储操作，以及大量的计算。</p>
<p><em>有疑问的可以在评论区留言一起讨论~~<br>end</em></p>

    

    
</div>


                

                <!-- Post Comments -->
                
                    







                
            </div>

            <!-- Post Prev & Next Nav -->
            <nav class="material-nav mdl-color-text--grey-50 mdl-cell mdl-cell--12-col">
    <!-- Prev Nav -->
    
        <a href="/2017/05/06/30分钟上手最火android网络请求框架Retrofit/" id="post_nav-newer" class="prev-content">
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_back</i>
            </button>
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            新篇
        </a>
    

    <!-- Section Spacer -->
    <div class="section-spacer"></div>

    <!-- Next Nav -->
    
        <a href="/2017/05/06/React Native入门一<初识ReactNative>/" id="post_nav-older" class="next-content">
            旧篇
            &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;
            <button class="mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon mdl-color--white mdl-color-text--grey-900" role="presentation">
                <i class="material-icons">arrow_forward</i>
            </button>
        </a>
    
</nav>

        </div>
    </div>



                    
                        <!-- Overlay For Active Sidebar -->
<div class="sidebar-overlay"></div>

<!-- Material sidebar -->
<aside id="sidebar" class="sidebar sidebar-colored sidebar-fixed-left" role="navigation">
    <div id="sidebar-main">
        <!-- Sidebar Header -->
        <div class="sidebar-header header-cover" style="background-image: url(/img/sidebar_header.png);">
    <!-- Top bar -->
    <div class="top-bar"></div>

    <!-- Sidebar toggle button -->
    <button type="button" class="sidebar-toggle mdl-button mdl-js-button mdl-js-ripple-effect mdl-button--icon" style="display: initial;" data-upgraded=",MaterialButton,MaterialRipple">
        <i class="material-icons">clear_all</i>
        <span class="mdl-button__ripple-container">
            <span class="mdl-ripple">
            </span>
        </span>
    </button>

    <!-- Sidebar Avatar -->
    <div class="sidebar-image">
        <img src="/img/avatar.png" alt="koala's avatar">
    </div>

    <!-- Sidebar Email -->
    <a data-toggle="dropdown" class="sidebar-brand" href="#settings-dropdown">
        youremail@email.com
        <b class="caret"></b>
    </a>
</div>


        <!-- Sidebar Navigation  -->
        <ul class="nav sidebar-nav">
    <!-- User dropdown  -->
    <li class="dropdown">
        <ul id="settings-dropdown" class="dropdown-menu">
            
                <li>
                    <a href="#" target="_blank" title="Email Me">
                        
                            <i class="material-icons sidebar-material-icons sidebar-indent-left1pc-element">email</i>
                        
                        Email Me
                    </a>
                </li>
            
        </ul>
    </li>

    <!-- Homepage -->
    
        <li id="sidebar-first-li">
            <a href="/" target="_self">
                
                    <i class="material-icons sidebar-material-icons">home</i>
                
                主页
            </a>
        </li>
        
    

    <!-- Archives  -->
    
        <li class="dropdown">
            <a href="#" class="ripple-effect dropdown-toggle" data-toggle="dropdown">
                
                    <i class="material-icons sidebar-material-icons">inbox</i>
                
                    归档
                <b class="caret"></b>
            </a>
            <ul class="dropdown-menu">
            <li>
                <a class="sidebar_archives-link" href="/archives/2017/05/">五月 2017<span class="sidebar_archives-count">6</span></a></li><li><a class="sidebar_archives-link" href="/archives/2017/04/">四月 2017<span class="sidebar_archives-count">2</span></a>
            </ul>
        </li>
        
    

    <!-- Categories  -->
    

    <!-- Pages  -->
    

    <!-- Article Number  -->
    
</ul>


        <!-- Sidebar Footer -->
        <!--
I'm glad you use this theme, the development is no so easy, I hope you can keep the copyright, I will thank you so much.
If you still want to delete the copyrights, could you still retain the first one? Which namely "Theme Material"
It will not impact the appearance and can give developers a lot of support :)

很高兴您使用并喜欢该主题，开发不易 十分谢谢与希望您可以保留一下版权声明。
如果您仍然想删除的话 能否只保留第一项呢？即 "Theme Material"
它不会影响美观并可以给开发者很大的支持和动力。 :)
-->

<!-- Sidebar Divider -->

    <div class="sidebar-divider"></div>


<!-- Theme Material -->

    <a href="https://github.com/viosey/hexo-theme-material"  class="sidebar-footer-text-a" target="_blank">
        <div class="sidebar-text mdl-button mdl-js-button mdl-js-ripple-effect sidebar-footer-text-div" data-upgraded=",MaterialButton,MaterialRipple">
            主题 - Material
            <span class="sidebar-badge badge-circle">i</span>
        </div>
    </a>


<!-- Help & Support -->
<!--

-->

<!-- Feedback -->
<!--

-->

<!-- About Theme -->
<!--

-->

    </div>

    <!-- Sidebar Image -->
    

</aside>

                    

                    
                        <!-- Footer Top Button -->
                        <div class="toTop-wrap">
    <a href="#top" class="toTop">
        <i class="material-icons footer_top-i">expand_less</i>
    </a>
</div>

                    

                    <!--Footer-->
<footer class="mdl-mini-footer" id="bottom">
    
        <!-- Paradox Footer Left Section -->
        <div class="mdl-mini-footer--left-section sns-list">
    <!-- Twitter -->
    
        <a href="https://twitter.com/twitter" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-twitter.svg);">
                <span class="visuallyhidden">Twitter</span>
            </button><!--
     --></a>
    

    <!-- Facebook -->
    
        <a href="https://www.facebook.com/facebook" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-facebook.svg);">
                <span class="visuallyhidden">Facebook</span>
            </button><!--
     --></a>
    

    <!-- Google + -->
    
        <a href="https://www.google.com/" target="_blank">
            <button class="mdl-mini-footer--social-btn social-btn" style="background-image: url(/img/footer/footer_ico-gplus.svg);">
                <span class="visuallyhidden">Google Plus</span>
            </button><!--
     --></a>
    

    <!-- Weibo -->
    

    <!-- Instagram -->
    

    <!-- Tumblr -->
    

    <!-- Github -->
    

    <!-- LinkedIn -->
    

    <!-- Zhihu -->
    

    <!-- Bilibili -->
    

    <!-- Telegram -->
    
</div>


        <!--Copyright-->
        <div id="copyright">
            Copyright&nbsp;©&nbsp;
            <script type="text/javascript">
                var fd = new Date();
                document.write(fd.getFullYear());
            </script>
            &nbsp;koala
        </div>

        <!-- Paradox Footer Right Section -->

        <!--
        I am glad you use this theme, the development is no so easy, I hope you can keep the copyright.
        It will not impact the appearance and can give developers a lot of support :)

        很高兴您使用该主题，开发不易，希望您可以保留一下版权声明。
        它不会影响美观并可以给开发者很大的支持。 :)
        -->

        <div class="mdl-mini-footer--right-section">
            <div>
                <div class="footer-develop-div">Powered by <a href="https://hexo.io" target="_blank" class="footer-develop-a">Hexo</a></div>
                <div class="footer-develop-div">Theme - <a href="https://github.com/viosey/hexo-theme-material" target="_blank" class="footer-develop-a">Material</a></div>
            </div>
        </div>
    
</footer>


                    <!-- Import File -->

    <script src="/js/lazyload.min.js"></script>
    <script src="/js/js.min.js"></script>



    <script src="/js/nprogress.js"></script>


<script type="text/javascript">
    NProgress.configure({
        showSpinner: true
    });
    NProgress.start();
    $('#nprogress .bar').css({
        'background': '#29d'
    });
    $('#nprogress .peg').css({
        'box-shadow': '0 0 10px #29d, 0 0 15px #29d'
    });
    $('#nprogress .spinner-icon').css({
        'border-top-color': '#29d',
        'border-left-color': '#29d'
    });
    setTimeout(function() {
        NProgress.done();
        $('.fade').removeClass('out');
    }, 800);
</script>
















<!-- Window Load-->
<script>
    $(window).load(function() {
        // Post_Toc parent position fixed
        $('.post-toc-wrap').parent('.mdl-menu__container').css('position', 'fixed');
    });
</script>

<!-- MathJax Load-->

<script>
    <!-- Offer LazyLoad -->
    queue.offer(function(){
        $('.lazy').lazyload({
            effect : 'show'
        });
    });

    <!-- Start Queue -->
    $(document).ready(function(){
        setTimeout(function(){
            setInterval(function(){
                queue.execNext();
            },200);
        },3000);
    });
</script>

                </main>
            </div>
        </body>
    
</html>
